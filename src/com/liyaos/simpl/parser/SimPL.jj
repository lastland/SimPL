/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. SimPL.jj */
/*@egen*/options {
    STATIC = false;
                   
                 
                             
                             
    KEEP_LINE_COLUMN = true;
}

PARSER_BEGIN (SimPLParser)
    package com.liyaos.simpl.parser;
    import java.io.FileInputStream;
    import java.io.File;
    import java.io.FileNotFoundException;
    class SimPLParser/*@bgen(jjtree)*/implements SimPLParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTSimPLParserState jjtree = new JJTSimPLParserState();

/*@egen*/
	public static void main(String[] args)
	throws ParseException, TokenMgrError, FileNotFoundException {
	    SimPLParser parser = new SimPLParser(new FileInputStream(new File("test_input.txt")));
	    parser.Start();
	    System.out.println("Success!");
	}
    }
PARSER_END (SimPLParser)

SKIP: {" " | "\t"}
SKIP: {"\n" | "\r" | "\r\n"}
// key words
TOKEN: {
    <LET: "let">
    | <IN: "in">
    | <END: "end">
    | <IF: "if">
    | <THEN: "then">
    | <ELSE: "else">
    | <WHILE: "while">
    | <DO: "do">
    | <FST: "fst">
    | <SND: "snd">
    | <HEAD: "head">
    | <TAIL: "tail">
    | <FUN: "fun">
    | <NIL: "nil">
}
// program operators
TOKEN: {
    <CONS: "::">
    | <OPAR: "(">
    | <CPAR: ")">
    | <COMMA: "," >
    | <ASSIGN: ":=">
    | <SEMICOLON: ";">
    | <DEFUN: "->">
}
// data type
TOKEN: {
    <INT: (["0"-"9"])+>
    | <BOOL: "true" | "false">
}
// bop
TOKEN: {
    <PLUS: "+">
    | <MINUS: "-">
    | <TIMES: "*">
    | <DIVIDE: "/">
    | <EQ: "=">
    | <GREATERTHAN: ">">
    | <LESSTHAN: "<">
    | <AND: "and">
    | <OR: "or">
}
// uop
TOKEN: {
    <UMINUS: "~">
    | <NOT: "not">
}
// identifier
TOKEN: {
    <IDENTIFIER: ["a"-"z"](["a"-"z", "0"-"9"])*>
}

ASTProgram Start()         :
{/*@bgen(jjtree) Program */
  ASTProgram jjtn000 = new ASTProgram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
    try {
/*@egen*/
    Expression()
    <EOF>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
	return jjtn000;
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Expression():
{}
{
    Sequence()
}

void LetExpression()      :
{/*@bgen(jjtree) Let */
  ASTLet jjtn000 = new ASTLet(JJTLET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Let */
    try {
/*@egen*/
    <LET>
    Identifier()
    <EQ>
    Expression()
    <IN>
    Expression()
    <END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void IfExpression()     :
{/*@bgen(jjtree) If */
  ASTIf jjtn000 = new ASTIf(JJTIF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) If */
    try {
/*@egen*/
    <IF>
    Expression()
    <THEN>
    Expression()
    <ELSE>
    Expression()
    <END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void WhileExpression()        :
{/*@bgen(jjtree) While */
  ASTWhile jjtn000 = new ASTWhile(JJTWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) While */
    try {
/*@egen*/
    <WHILE>
    Expression()
    <DO>
    Expression()
    <END>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/ 
}

void Sequence():
{}
{/*@bgen(jjtree) #Sequence(> 1) */
    {
      ASTSequence jjtn001 = new ASTSequence(JJTSEQUENCE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (OneExpression()
    (<SEMICOLON>OneExpression())*)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
      }
    }
/*@egen*/              
}

void OneExpression() :
{}
{
    AnonymousFunction()
    | LetExpression()
    | IfExpression()
    | WhileExpression()
    | LOOKAHEAD(2) AssignmentExpression()
    | ConsExpression()
}

void AnonymousFunction()                   :
{/*@bgen(jjtree) AnonymousFunction */
  ASTAnonymousFunction jjtn000 = new ASTAnonymousFunction(JJTANONYMOUSFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AnonymousFunction */
    try {
/*@egen*/
    <FUN> Identifier() <DEFUN>
    OneExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AssignmentExpression()             :
{/*@bgen(jjtree) Assignment */
  ASTAssignment jjtn000 = new ASTAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Assignment */
    try {
/*@egen*/
    Identifier() <ASSIGN>OneExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ConsExpression():
{}
{
    AndOrExpression()
    (<CONS>/*@bgen(jjtree) #Cons( 2) */
            {
              ASTCons jjtn001 = new ASTCons(JJTCONS);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*/ AndOrExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte001) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte001 instanceof RuntimeException) {
                throw (RuntimeException)jjte001;
              }
              if (jjte001 instanceof ParseException) {
                throw (ParseException)jjte001;
              }
              throw (Error)jjte001;
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  2);
              }
            }
/*@egen*/         )*
}

void AndOrExpression():
{}
{  
    CompareExpression()
    ((<AND>/*@bgen(jjtree) #And( 2) */
            {
              ASTAnd jjtn001 = new ASTAnd(JJTAND);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
            }
            try {
/*@egen*/ CompareExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte001) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte001 instanceof RuntimeException) {
                throw (RuntimeException)jjte001;
              }
              if (jjte001 instanceof ParseException) {
                throw (ParseException)jjte001;
              }
              throw (Error)jjte001;
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  2);
              }
            }
/*@egen*/        )
    | (<OR>/*@bgen(jjtree) #Or( 2) */
            {
              ASTOr jjtn002 = new ASTOr(JJTOR);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
            }
            try {
/*@egen*/ CompareExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  2);
              }
            }
/*@egen*/       ))*
}

void CompareExpression():
{}
{
    AdditiveExpression()
    ((<EQ>/*@bgen(jjtree) #Eq( 2) */
           {
             ASTEq jjtn001 = new ASTEq(JJTEQ);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
           }
           try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
           } catch (Throwable jjte001) {
             if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte001 instanceof RuntimeException) {
               throw (RuntimeException)jjte001;
             }
             if (jjte001 instanceof ParseException) {
               throw (ParseException)jjte001;
             }
             throw (Error)jjte001;
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001,  2);
             }
           }
/*@egen*/       )
    | (<GREATERTHAN>/*@bgen(jjtree) #GreaterThan( 2) */
                     {
                       ASTGreaterThan jjtn002 = new ASTGreaterThan(JJTGREATERTHAN);
                       boolean jjtc002 = true;
                       jjtree.openNodeScope(jjtn002);
                     }
                     try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                     } catch (Throwable jjte002) {
                       if (jjtc002) {
                         jjtree.clearNodeScope(jjtn002);
                         jjtc002 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte002 instanceof RuntimeException) {
                         throw (RuntimeException)jjte002;
                       }
                       if (jjte002 instanceof ParseException) {
                         throw (ParseException)jjte002;
                       }
                       throw (Error)jjte002;
                     } finally {
                       if (jjtc002) {
                         jjtree.closeNodeScope(jjtn002,  2);
                       }
                     }
/*@egen*/                )
    | (<LESSTHAN>/*@bgen(jjtree) #LessThan( 2) */
                  {
                    ASTLessThan jjtn003 = new ASTLessThan(JJTLESSTHAN);
                    boolean jjtc003 = true;
                    jjtree.openNodeScope(jjtn003);
                  }
                  try {
/*@egen*/ AdditiveExpression()/*@bgen(jjtree)*/
                  } catch (Throwable jjte003) {
                    if (jjtc003) {
                      jjtree.clearNodeScope(jjtn003);
                      jjtc003 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte003 instanceof RuntimeException) {
                      throw (RuntimeException)jjte003;
                    }
                    if (jjte003 instanceof ParseException) {
                      throw (ParseException)jjte003;
                    }
                    throw (Error)jjte003;
                  } finally {
                    if (jjtc003) {
                      jjtree.closeNodeScope(jjtn003,  2);
                    }
                  }
/*@egen*/             ))*
}

void AdditiveExpression():
{}
{
    Term()
    ((<PLUS>/*@bgen(jjtree) #Plus( 2) */
             {
               ASTPlus jjtn001 = new ASTPlus(JJTPLUS);
               boolean jjtc001 = true;
               jjtree.openNodeScope(jjtn001);
             }
             try {
/*@egen*/ Term()/*@bgen(jjtree)*/
             } catch (Throwable jjte001) {
               if (jjtc001) {
                 jjtree.clearNodeScope(jjtn001);
                 jjtc001 = false;
               } else {
                 jjtree.popNode();
               }
               if (jjte001 instanceof RuntimeException) {
                 throw (RuntimeException)jjte001;
               }
               if (jjte001 instanceof ParseException) {
                 throw (ParseException)jjte001;
               }
               throw (Error)jjte001;
             } finally {
               if (jjtc001) {
                 jjtree.closeNodeScope(jjtn001,  2);
               }
             }
/*@egen*/         )
    | (<MINUS>/*@bgen(jjtree) #Minus( 2) */
               {
                 ASTMinus jjtn002 = new ASTMinus(JJTMINUS);
                 boolean jjtc002 = true;
                 jjtree.openNodeScope(jjtn002);
               }
               try {
/*@egen*/ Term()/*@bgen(jjtree)*/
               } catch (Throwable jjte002) {
                 if (jjtc002) {
                   jjtree.clearNodeScope(jjtn002);
                   jjtc002 = false;
                 } else {
                   jjtree.popNode();
                 }
                 if (jjte002 instanceof RuntimeException) {
                   throw (RuntimeException)jjte002;
                 }
                 if (jjte002 instanceof ParseException) {
                   throw (ParseException)jjte002;
                 }
                 throw (Error)jjte002;
               } finally {
                 if (jjtc002) {
                   jjtree.closeNodeScope(jjtn002,  2);
                 }
               }
/*@egen*/          ))*
}

void Term():
{}
{
    Factor() 
    ((<TIMES>/*@bgen(jjtree) #Times( 2) */
              {
                ASTTimes jjtn001 = new ASTTimes(JJTTIMES);
                boolean jjtc001 = true;
                jjtree.openNodeScope(jjtn001);
              }
              try {
/*@egen*/ Factor()/*@bgen(jjtree)*/
              } catch (Throwable jjte001) {
                if (jjtc001) {
                  jjtree.clearNodeScope(jjtn001);
                  jjtc001 = false;
                } else {
                  jjtree.popNode();
                }
                if (jjte001 instanceof RuntimeException) {
                  throw (RuntimeException)jjte001;
                }
                if (jjte001 instanceof ParseException) {
                  throw (ParseException)jjte001;
                }
                throw (Error)jjte001;
              } finally {
                if (jjtc001) {
                  jjtree.closeNodeScope(jjtn001,  2);
                }
              }
/*@egen*/          )
    | (<DIVIDE>/*@bgen(jjtree) #Divide( 2) */
                {
                  ASTDivide jjtn002 = new ASTDivide(JJTDIVIDE);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                }
                try {
/*@egen*/ Factor()/*@bgen(jjtree)*/
                } catch (Throwable jjte002) {
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte002 instanceof RuntimeException) {
                    throw (RuntimeException)jjte002;
                  }
                  if (jjte002 instanceof ParseException) {
                    throw (ParseException)jjte002;
                  }
                  throw (Error)jjte002;
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002,  2);
                  }
                }
/*@egen*/           ))*
}

void Factor():
{}
{
    NegativeExpression()
    | NotExpression()
    | AtomExpression()
}

void NegativeExpression()           :
{/*@bgen(jjtree) Negative */
  ASTNegative jjtn000 = new ASTNegative(JJTNEGATIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Negative */
    try {
/*@egen*/
    <UMINUS> AtomExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NotExpression()      :
{/*@bgen(jjtree) Not */
  ASTNot jjtn000 = new ASTNot(JJTNOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Not */
    try {
/*@egen*/
    <NOT> AtomExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AtomExpression():
{}
{
    Integer()
    | Bool()
    | Identifier()
    | FstExpression()
    | SndExpression()
    | HeadExpression()
    | TailExpression()
    // Can these `LOOKAHEAD` be eliminated?
    | LOOKAHEAD(BracketExpression()) BracketExpression()
    | LOOKAHEAD(PairExpression()) PairExpression()
    | AppExpression()
}

void Bool()       :
{/*@bgen(jjtree) Bool */
    ASTBool jjtn000 = new ASTBool(JJTBOOL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Bool */
    try {
/*@egen*/
    t = <BOOL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
	jjtn000.setValue(t.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Integer()      :
{/*@bgen(jjtree) Int */
    ASTInt jjtn000 = new ASTInt(JJTINT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Int */
    try {
/*@egen*/
    t = <INT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
	jjtn000.setValue(t.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Identifier()             :
{/*@bgen(jjtree) Identifier */
    ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/
    t = <IDENTIFIER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
	jjtn000.setValue(t.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FstExpression()      :
{/*@bgen(jjtree) Fst */
  ASTFst jjtn000 = new ASTFst(JJTFST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Fst */
    try {
/*@egen*/
    <FST> AtomExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SndExpression()     :
{/*@bgen(jjtree) Snd */
  ASTSnd jjtn000 = new ASTSnd(JJTSND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Snd */
    try {
/*@egen*/
    <SND> AtomExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void HeadExpression()      :
{/*@bgen(jjtree) Head */
  ASTHead jjtn000 = new ASTHead(JJTHEAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Head */
    try {
/*@egen*/
    <HEAD> AtomExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void TailExpression()      :
{/*@bgen(jjtree) Tail */
  ASTTail jjtn000 = new ASTTail(JJTTAIL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Tail */
    try {
/*@egen*/
    <TAIL> AtomExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void AppExpression()              :
{/*@bgen(jjtree) Application */
  ASTApplication jjtn000 = new ASTApplication(JJTAPPLICATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Application */
    try {
/*@egen*/
    <OPAR> Expression() Expression() <CPAR>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void PairExpression()       :
{/*@bgen(jjtree) Pair */
  ASTPair jjtn000 = new ASTPair(JJTPAIR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Pair */
    try {
/*@egen*/
    <OPAR> Expression() <COMMA> Expression() <CPAR>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void BracketExpression()          :
{/*@bgen(jjtree) Bracket */
  ASTBracket jjtn000 = new ASTBracket(JJTBRACKET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Bracket */
    try {
/*@egen*/
    <OPAR> Expression() <CPAR>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
